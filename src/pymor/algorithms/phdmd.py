# This file is part of the pyMOR project (https://www.pymor.org).
# Copyright pyMOR developers and contributors. All rights reserved.
# License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)

import numpy as np
from scipy.linalg import eigh, lstsq, svd
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

from pymor.algorithms.to_matrix import to_matrix
from pymor.core.exceptions import PHDMDError
from pymor.core.logger import getLogger
from pymor.models.iosys import PHLTIModel
from pymor.operators.interface import Operator


def phdmd(X, Y, U, Xdot=None, dt=None, H=None, initial_J=None, initial_R=None, initial_alpha=0.1, miniter=0,
          maxiter=30, atol=1e-12, rtol=1e-10, weighted_rtol=1e-12, skew_procrustes_rtol=1e-12):
    r"""Solve the pH DMD problem.

    This method solves the optimization problem::

    .. math::
        \min_{J, R} ||Z - (J - R) T||_F

    such that :math:`J \in \mathbb{R}^{(n + m) \times (n + m)}` is a skew-symmetric matrix and
    :math:`R \in \mathbb{R}^{(n + m) \times (n + m)}` is symmetric and positive semidefinite.
    The data matrices :math:`T \in \mathbb{R}^{(n + m) \times k}` and
    :math:`Z \in \mathbb{R}^{(n + m) \times k}` are constructed as follows::

    .. math::
        T = (X^T, U^T)^T, Z = ({H \dot{X}}^T, -Y^T)^T

    from `X \in \mathbb{R}^{n \times k}`, `Y \in \mathbb{R}^{m \times k}`,
    `U \in \mathbb{R}^{m \times k}`, and either derivative `Xdot \in \mathbb{R}^{n \times k}`
    or an approximation of the derivative data obtained from `X` itself.

    The formal description of this algorithm can be found in :cite:`MMU22`.

    Parameters
    ----------
    X
        The `NumPy array` of the system state data with dimension `n` and length `k`.
    Y
        The `NumPy array` of the system output data with shape `(m, k)`.
    U
        The `NumPy array` of the system control data with shape `(m, k)`.
    Xdot
        If not `None`, the `NumPy array` of the system time derivative data with dimension `n` and
        length `k`. If `None`, `dt` will be used to estimate this data from `X` using
        an implicit midpoint rule.
    dt
        See `Xdot`.
    H
        If not `None`, the `NumPy array` representing the systems Hamiltonian.
    initial_J
        If not `None`, the `NumPy array` representing the initial
        guess for the :math:`J \in \mathbb{R}^{(n + m) \times (n + m)}` operator.
    initial_R
        If not `None`, the `NumPy array` representing the initial
        guess for the :math:`R \in \mathbb{R}^{(n + m) \times (n + m)}` operator.
    initial_alpha
        The initial value used in calculating the update step.
    miniter
        Minimum amount of iterations to perform.
    maxiter
        Fail if the iteration count reaches this value without converging.
    atol
        Finish when the absolute error measure is below this threshold.
    rtol
        Finish when the relative update error measure is below this threshold.
    weighted_rtol
        In the weighted pH DMD initialization problem, truncate when the relative value is
        below this threshold.
    skew_procrustes_rtol
        In the skew-symmetric Procrustes problem, truncate when the relative value is
        below this threshold.

    Returns
    -------
    inf_model
        The inferred |PHLTIModel|.
    data
        Dict containing the following fields:

            :update_norms:          |NumPy array| of the norms of the update vectors after
                                    each iteration.
            :abs_errs:              |NumPy array| of the absolute errors after each iteration.
            :rel_errs:              |NumPy array| of the relative  errors after each iteration.
            :iterations:            Number of total pH DMD iterations.
            :skew_procrustes_data:  `list` of data generated by the skew-symmetric
                                    Procrustes subproblems.
            :weighted_init_data:    If `initial_J` and `initial_R` are both `None`, dict of data
                                    generated by the weighted pH DMD initialization subproblem.
            :skew_init_data:        If only `initial_J` is `None`, dict of data generated by the
                                    skew-symmetric Procrustes subproblem.
            :spsd_init_data:        If only `initial_R` is `None`, dict of data generated by the psd
                                    symmetric Procrustes subproblem.
    """
    assert isinstance(X, np.ndarray)
    assert isinstance(Y, np.ndarray)
    assert isinstance(U, np.ndarray)
    assert X.shape[1] == Y.shape[1]
    assert U.shape == Y.shape
    assert 0. < initial_alpha < 1.

    logger = getLogger('pymor.algorithms.phdmd.phdmd')

    if Xdot is None:
        assert dt is not None
        Xdot = (X[:, 1:] - X[:, :-1]) * (1. / dt)
    else:
        assert isinstance(Xdot, np.ndarray)
        assert X.shape == Xdot.shape
        assert Xdot.shape[1] == U.shape[1]
        Xdot = .5 * (Xdot[:, 1:] + Xdot[:, :-1])

    X = .5 * (X[:, 1:] + X[:, :-1])
    Y = .5 * (Y[:, 1:] + Y[:, :-1])
    U = .5 * (U[:, 1:] + U[:, :-1])

    state_dim = X.shape[0]

    if H is None:
        logger.warn('No H matrix provided. Did you intend this?')
        H = np.eye(state_dim)

    assert isinstance(H, np.ndarray)
    assert H.shape[0] == H.shape[1] == state_dim

    T = np.concatenate([X, U])
    Z = np.concatenate([H @ Xdot, -Y])
    data = {}

    if initial_J is None and initial_R is not None:
        logger.info('Solving skew-symmetric Procrustes problem to get initial operators...')
        if isinstance(initial_R, Operator):
            initial_R = to_matrix(initial_R)
        initial_J, skew_data = _skew_symmetric_procrustes(T, initial_R @ T + Z, rtol=skew_procrustes_rtol)
        data['skew_init_data'] = skew_data
    elif initial_J is not None and initial_R is None:
        logger.info('Solving spsd Procrustes problem to get initial operators...')
        if isinstance(initial_J, Operator):
            initial_J = to_matrix(initial_J)
        initial_R, spsd_data = _initial_psd_symmetric_procrustes(T, initial_J @ T - Z)
        data['spsd_init_data'] = spsd_data
    elif initial_J is None and initial_R is None:
        logger.info('Solving weighted problem to get initial operators...')
        initial_J, initial_R, weighted_data = _weighted_phdmd(T, Z, rtol=weighted_rtol)
        data['weighted_init_data'] = weighted_data

    assert isinstance(initial_J, np.ndarray) and isinstance(initial_R, np.ndarray)
    assert initial_J.shape == initial_R.shape

    J = initial_J
    R = initial_R

    logger.info('Running pH DMD algorithm...')

    sing_vals = eigh(T @ T.T, eigvals_only=True)
    L = max(sing_vals)
    mu = min(sing_vals)
    sing_ratio = mu / L

    alphas = [initial_alpha]
    betas = []
    abs_errs = [ np.linalg.norm(Z - (J - R) @ T) ]
    rel_errs = [ abs_errs[0] / np.linalg.norm(Z) ]
    update_norms = []
    procrustes_data = []

    Q = R
    iteration = 0
    update_norm = np.inf
    while True:
        logger.info(f'Starting pH DMD algorithm iteration {iteration} with '
                    f'current errors abs: {abs_errs[-1]} rel: {rel_errs[-1]}...')

        if iteration >= miniter:
            if abs_errs[-1] < atol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'absolute error tolerance of {atol} was reached.')
                break
            if rel_errs[-1] < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative error tolerance of {rtol} was reached.')
                break
            if update_norm < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative update tolerance of {rtol} was reached.')
                break
            if iteration >= maxiter:
                logger.info(f'Maximum iterations reached. Failed to converge after {iteration} iterations.')
                raise PHDMDError('Failed to converge after the maximum amount of iterations.')

        iteration += 1

        R_prev = R
        J_prev = J
        last_alpha = alphas[-1]

        Z_1 = Z + R @ T
        logger.info('Solving skew-symmetric Procrustes subproblem...')
        J, skew_procrustes_data = _skew_symmetric_procrustes(T, Z_1, rtol=skew_procrustes_rtol)
        procrustes_data.append(skew_procrustes_data)
        Z_2 = J @ T - Z
        G = Q @ T @ T.T - Z_2 @ T.T

        R = _project_spsd(Q - (1. / L) * G)
        alpha = np.sqrt((last_alpha ** 2 - sing_ratio) ** 2 + 4 * last_alpha ** 2)
        alpha += (sing_ratio - last_alpha ** 2)
        alpha /= 2.
        beta = last_alpha * (1 - last_alpha) / (last_alpha ** 2 + alpha)
        Q = R + beta * (R - R_prev)

        alphas.append(alpha)
        betas.append(beta)

        abs_errs.append(np.linalg.norm(Z - (J - R) @ T))
        rel_errs.append(abs_errs[-1] / np.linalg.norm(Z))
        update_norm = np.linalg.norm(J_prev - J, 'fro') / np.linalg.norm(J, 'fro') \
                    + np.linalg.norm(R_prev - R, 'fro') / np.linalg.norm(J, 'fro')
        update_norms.append(update_norm)

    data['update_norms'] = np.array(update_norms)
    data['abs_errs'] = np.array(abs_errs)
    data['rel_errs'] = np.array(rel_errs)
    data['iterations'] = iteration
    data['skew_procrustes_data'] = procrustes_data

    inf_J = J[:state_dim, :state_dim]
    inf_G = J[:state_dim, state_dim:]
    inf_N = J[state_dim:, state_dim:]
    inf_R = R[:state_dim, :state_dim]
    inf_P = R[:state_dim, state_dim:]
    inf_S = R[state_dim:, state_dim:]
    inf_model = PHLTIModel.from_matrices(
        J=inf_J, R=inf_R, G=inf_G, P=inf_P, N=inf_N, S=inf_S, E=H
    )

    return inf_model, data


def _weighted_phdmd(X, Y, rtol=1e-12):
    r"""Solve the weighted pH DMD problem.

    This method solves the optimization problem::

    .. math::
        min_{J, R} ||T^T Z - T^T (J - R) T||_F

    such that :math:`J` is a skew-symmetric matrix and :math:`R` is symmetric and positive
    semidefinite. The data matrices :math:`T` and :math:`Z` are constructed as follows::

    .. math::
        T = (X, U)^T, Z = (H \dot{X}, -Y)^T

    from `X`, `Y`, `U`, and either derivative `Xdot` or an approximation of the derivative data
    obtained from `X` itself.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The `NumPy array` of the system data.
    Y
        The `NumPy array` of the system output data.
    rtol
        Truncate the singular values when the ratio with respect to the largest singular value
        is below this threshold.

    Returns
    -------
    J
        The initial `NumPy array` for `J`.
    R
        The initial `NumPy array` for `R`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute solution error.
            :rel:   Value of relative solution error.
    """
    assert isinstance(X, np.ndarray) and isinstance(Y, np.ndarray)
    assert X.shape == Y.shape

    logger = getLogger('pymor.algorithms.phdmd.weighted_phdmd')

    data_dim = X.shape[0]

    U, s_vals, V = svd(X)

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_S = diags(s_vals[:rank])
    trunc_S_inv = diags(1. / s_vals[:rank])

    if rank < data_dim:
        logger.warn(f'Deficient rank ({rank} < {data_dim})!')

    Z_1 = U.T @ Y @ V.T

    helper = trunc_S @ Z_1[:rank, :rank]
    J_11 = .5 * (helper - helper.T)
    R_11 = _project_spsd(-helper)
    J = U[:, :rank] @ trunc_S_inv @ J_11 @ trunc_S_inv @ U[:, :rank].T
    R = U[:, :rank] @ trunc_S_inv @ R_11 @ trunc_S_inv @ U[:, :rank].T

    if rank < data_dim:
        J_21 = lstsq(trunc_S.toarray(), Z_1[rank:, :rank].T, cond=None)[0].T

        top_filler = np.zeros((rank, rank))
        bottom_filler = np.zeros((data_dim - rank, data_dim - rank))
        compensation = np.block([
            [top_filler, -J_21.T],
            [J_21, bottom_filler]
        ])

        J = J + U @ compensation @ U.T

    abs_err = np.linalg.norm(X.T @ Y - X.T @ (J - R) @ X, 'fro')
    rel_err = abs_err / np.linalg.norm(X.T @ Y, 'fro')
    data = {'abs': abs_err, 'rel': rel_err}

    return J, R, data


def _project_spsd(matrix):
    """Project the matrix onto the set of symmetric and positive semidefinite matrices.

    Not intended to be used directly.

    Parameters
    ----------
    matrix
        The `NumPy array` containing the matrix to project.
    """
    assert isinstance(matrix, np.ndarray)

    matrix = .5 * (matrix + matrix.T)
    eig_vals, eig_vecs = eigh(matrix)
    return eig_vecs @ diags(eig_vals.clip(min = 0)) @ eig_vecs.T


def _skew_symmetric_procrustes(X, Y, rtol=1e-12):
    """Solve the skew-symmetric Procrustes problem.

    Computes a solution A of the minimization problem ::

    .. math::
        min_{A} ||AX - Y||_F

    used in the ph DMD algorithm, such that :math:`A` is skew-symmetric .

    Not intended to be used directly.

    Parameters
    ----------
    X
        The `NumPy array` of the system data.
    Y
        The `NumPy array` of the system output data.
    rtol
        Truncate the singular values and matrix entries of :math:`A` when the ratio with respect
        to the largest value is below this threshold.

    Returns
    -------
    A
        The `NumPy array` containing the matrix mapping `X` to `Y`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute fitting error.
            :rel:   Value of relative fitting error.
    """
    assert isinstance(X, np.ndarray) and isinstance(Y, np.ndarray)
    assert X.shape == Y.shape

    data_dim = X.shape[0]

    U, s_vals, V = svd(X)
    V = V.conj().T

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_s_vals = s_vals[:rank]
    trunc_S = diags(trunc_s_vals)

    Y_trans = U.T @ Y @ V
    Z_1 = Y_trans[:rank, :rank]
    Z_3 = Y_trans[rank:, :rank].T

    [ii, jj] = np.mgrid[:rank, :rank]
    phi = 1. / (np.square(trunc_s_vals[ii]) + np.square(trunc_s_vals[jj]))

    A_1 = phi * (Z_1 @ trunc_S - trunc_S @ Z_1.T)
    A_2 = -spsolve(trunc_S.tocsc(), Z_3)
    # if dimensions are unfortunately chosen, spsolve results in the following shapes:
    # Z_3.shape = (x, 1) -> A_2.shape = (x,)
    # this then breaks the block(...) afterwards
    if A_2.ndim == 1:
        A_2 = A_2[:, np.newaxis]
    A_4 = np.zeros((data_dim - rank, data_dim - rank))
    A = np.block([
        [A_1, A_2],
        [-A_2.T, A_4]
    ])
    A = U @ A @ U.T

    A_abs = np.abs(A)
    indices = np.where(A_abs / np.amax(A_abs) < rtol)
    A[indices] = 0.

    abs_err = np.linalg.norm(A @ (X) - Y)
    rel_err = abs_err / np.linalg.norm(Y)
    data = {'abs': abs_err, 'rel': rel_err}

    return A, data


def _initial_psd_symmetric_procrustes(X, Y, reg=1e-6):
    """Solve the psd symmetric Procrustes problem.

    Computes a solution A of the minimization problem ::

    .. math::
        min_{A} ||AX - Y||_F

    used as an initial guess in the pH DMD algorithm such that :math:`A` is
    symmetric and positive semidefinite.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The `NumPy array` of the system data.
    Y
        The `NumPy array` of the system output data.
    reg
        Regularization parameter applied to every element on the main diagonal
        to avoid singular matrices.

    Returns
    -------
    A
        The `NumPy array` containing the matrix mapping `X` to `Y`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute fitting error.
            :rel:   Value of relative fitting error.
    """
    assert isinstance(X, np.ndarray) and isinstance(Y, np.ndarray)
    assert X.shape == Y.shape

    data_dim = X.shape[0]

    A = np.zeros((data_dim, data_dim))
    for i in range(data_dim):
        X_row = X[i]
        A[i, i] = max(0, X_row @ Y[i].T) / np.linalg.norm(X_row) ** 2 + reg

    abs_err = np.linalg.norm(Y - A @ X)
    rel_err = abs_err / np.linalg.norm(Y)

    data = {}
    data = {'abs': abs_err, 'rel': rel_err}

    return A, data
