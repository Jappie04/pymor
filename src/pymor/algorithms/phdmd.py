# This file is part of the pyMOR project (https://www.pymor.org).
# Copyright pyMOR developers and contributors. All rights reserved.
# License: BSD 2-Clause License (https://opensource.org/licenses/BSD-2-Clause)

import numpy as np
from scipy.linalg import eigh, lstsq, svd
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

from pymor.algorithms.to_matrix import to_matrix
from pymor.core.exceptions import PHDMDError
from pymor.core.logger import getLogger
from pymor.models.iosys import PHLTIModel
from pymor.operators.block import BlockOperator
from pymor.operators.constructions import VectorArrayOperator
from pymor.operators.interface import Operator
from pymor.operators.numpy import NumpyMatrixOperator
from pymor.vectorarrays.block import BlockVectorSpace
from pymor.vectorarrays.interface import VectorArray


def phdmd(X, Y, U, Xdot=None, dt=None, H=None, initial_J=None, initial_R=None, initial_alpha=0.1, miniter=0,
          maxiter=30, atol=1e-12, rtol=1e-10, weighted_rtol=1e-12, skew_procrustes_rtol=1e-12):
    r"""Solve the pH DMD problem.

    This method solves the optimization problem::

    .. math::
        \min_{J, R} ||Z - (J - R) T||_F

    such that :math:`J` is a skew-symmetric matrix and :math:`R` is symmetric and positive
    semidefinite. The data matrices :math:`T` and :math:`Z` are constructed as follows::

        T = (X, U)^T, Z = (H \dot{X}, -Y)^T

    from `X`, `Y`, `U`, and either derivative `Xdot` or an approximation of the derivative data
    obtained from `X` itself.

    The formal description of this algorithm can be found in :cite:`MMU22`.

    Parameters
    ----------
    X
        The |VectorArray| of the system state data.
    Y
        The |VectorArray| of the system output data.
    U
        The |VectorArray| of the system control data.
    Xdot
        If not `None`, the |VectorArray| of the system time derivative data.
        If `None`, `dt` will be used to estimate this data from `X` using an implicit midpoint rule.
    dt
        See `Xdot`.
    H
        If not `None`, the `NumPy array` representing the systems Hamiltonian.
    initial_J
        If not `None`, the `Numpy array` representing the initial guess for the :math:`J` operator.
    initial_R
        If not `None`, the `Numpy array` representing the initial guess for the :math:`R` operator.
    initial_alpha
        The initial value used in calculating the update step.
    miniter
        Minimum amount of iterations to perform.
    maxiter
        Fail if the iteration count reaches this value without converging.
    atol
        Finish when the absolute error measure is below this threshold.
    rtol
        Finish when the relative update error measure is below this threshold.
    weighted_rtol
        In the weighted pH DMD initialization problem, truncate when the relative value is
        below this threshold.
    skew_procrustes_rtol
        In the skew-symmetric Procrustes problem, truncate when the relative value is
        below this threshold.

    Returns
    -------
    inf_model
        The inferred |PHLTIModel|.
    data
        Dict containing the following fields:

            :update_norms:          |NumPy array| of the norms of the update vectors after
                                    each iteration.
            :abs_errs:              |NumPy array| of the absolute errors after each iteration.
            :rel_errs:              |NumPy array| of the relative  errors after each iteration.
            :iterations:            Number of total pH DMD iterations.
            :skew_procrustes_data:  `list` of data generated by the skew-symmetric
                                    Procrustes subproblems.
            :weighted_init_data:    If `initial_J` and `initial_R` are both `None`, dict of data
                                    generated by the weighted pH DMD initialization subproblem.
            :skew_init_data:        If only `initial_J` is `None`, dict of data generated by the
                                    skew-symmetric Procrustes subproblem.
            :spsd_init_data:        If only `initial_R` is `None`, dict of data generated by the psd
                                    symmetric Procrustes subproblem.
    """
    assert isinstance(X, VectorArray)
    assert isinstance(Y, VectorArray)
    assert isinstance(U, VectorArray)
    assert len(X) == len(Y)
    assert len(X) % len(U) == 0
    assert 0. < initial_alpha < 1.

    logger = getLogger('pymor.algorithms.phdmd.phdmd')

    if Xdot is None:
        assert dt is not None
        Xdot = (X[1:] - X[:-1]) * (1. / dt)
    else:
        assert isinstance(Xdot, VectorArray)
        assert len(X) == len(Xdot)
        assert len(X) == len(U)
        Xdot = .5 * (Xdot[1:] + Xdot[:-1])

    X = .5 * (X[1:] + X[:-1])
    Y = .5 * (Y[1:] + Y[:-1])
    U = .5 * (U[1:] + U[:-1])

    block_space = BlockVectorSpace([X.space, U.space])
    space_dim = X.dim
    space_id = X.space.id

    if H is None:
        logger.warn('No H matrix provided. Did you intend this?')
        H = IdentityOperator(X.space)
    else:
        if isinstance(H, np.ndarray):
            assert len(H.shape) == 2
            H = NumpyMatrixOperator(H, source_id=space_id, range_id=space_id)
        elif isinstance(H, VectorArray):
            assert len(H) == H.dim == X.dim
            H = VectorArrayOperator(H, space_id=space_id)

    assert isinstance(H, Operator)
    assert H.source == H.range == X.space

    T = block_space.make_array([X, U])
    Z = block_space.make_array([H.apply(Xdot), -Y])
    data = {}

    if initial_J is None and initial_R is not None:
        logger.info('Solving skew-symmetric Procrustes problem to get initial operators...')
        if isinstance(initial_R, np.ndarray):
            initial_R = BlockOperator([
                [
                    NumpyMatrixOperator(initial_R[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
                    NumpyMatrixOperator(initial_R[:space_dim, space_dim:], range_id=space_id)
                ],
                [
                    NumpyMatrixOperator(initial_R[space_dim:, :space_dim], source_id=space_id),
                    NumpyMatrixOperator(initial_R[space_dim:, space_dim:])
                ]
            ])

        assert initial_R.source == block_space and initial_R.range == block_space
        initial_J, skew_data = _skew_symmetric_procrustes(T, initial_R.apply(T) + Z, rtol=skew_procrustes_rtol)
        data['skew_init_data'] = skew_data
    elif initial_J is not None and initial_R is None:
        logger.info('Solving spsd Procrustes problem to get initial operators...')
        if isinstance(initial_J, np.ndarray):
            initial_J = BlockOperator([
                [
                    NumpyMatrixOperator(initial_J[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
                    NumpyMatrixOperator(initial_J[:space_dim, space_dim:], range_id=space_id)
                ],
                [
                    NumpyMatrixOperator(initial_J[space_dim:, :space_dim], source_id=space_id),
                    NumpyMatrixOperator(initial_J[space_dim:, space_dim:])
                ]
            ])

        assert initial_J.source == block_space and initial_J.range == block_space
        initial_R, spsd_data = _initial_psd_symmetric_procrustes(T, initial_J.apply(T) - Z)
        data['spsd_init_data'] = spsd_data
    elif initial_J is None and initial_R is None:
        logger.info('Solving weighted problem to get initial operators...')
        initial_J, initial_R, weighted_data = _weighted_phdmd(T, Z, rtol=weighted_rtol)
        data['weighted_init_data'] = weighted_data

    assert isinstance(initial_J, BlockOperator) and isinstance(initial_R, BlockOperator)
    assert initial_J.source == initial_R.source == initial_J.range == initial_R.range

    J = initial_J
    R = initial_R

    logger.info('Running pH DMD algorithm...')

    sing_vals = eigh(T.inner(T), eigvals_only=True)
    L = max(sing_vals)
    mu = min(sing_vals)
    sing_ratio = mu / L

    alphas = [initial_alpha]
    betas = []
    abs_errs = [np.linalg.norm((Z - (J - R).apply(T)).norm(), 'fro')]
    rel_errs = [abs_errs[0] / np.linalg.norm(Z.norm(), 'fro')]
    update_norms = []
    procrustes_data = []

    Q = R
    iteration = 0
    update_norm = np.inf
    while True:
        logger.info(f'Starting pH DMD algorithm iteration {iteration} with '
                    f'current errors abs: {abs_errs[-1]} rel: {rel_errs[-1]}...')

        if iteration >= miniter:
            if abs_errs[-1] < atol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'absolute error tolerance of {atol} was reached.')
                break
            if rel_errs[-1] < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative error tolerance of {rtol} was reached.')
                break
            if update_norm < rtol:
                logger.info(f'pH DMD converged in {iteration} iterations because '
                            f'relative update tolerance of {rtol} was reached.')
                break
            if iteration >= maxiter:
                logger.info(f'Maximum iterations reached. Failed to converge after {iteration} iterations.')
                raise PHDMDError('Failed to converge after the maximum amount of iterations.')

        iteration += 1

        R_prev = R
        J_prev = J
        last_alpha = alphas[-1]

        Z_1 = Z + R.apply(T)
        logger.info('Solving skew-symmetric Procrustes subproblem...')
        J, skew_procrustes_data = _skew_symmetric_procrustes(T, Z_1, rtol=skew_procrustes_rtol)
        procrustes_data.append(skew_procrustes_data)
        Z_2 = J.apply(T) - Z
        G = Q.apply(T).to_numpy().T @ T.to_numpy() - Z_2.to_numpy().T @ T.to_numpy()

        R = _project_spsd(to_matrix(Q) - (1. / L) * G, dim=space_dim, id=space_id)
        alpha = np.sqrt((last_alpha ** 2 - sing_ratio) ** 2 + 4 * last_alpha ** 2)
        alpha += (sing_ratio - last_alpha ** 2)
        alpha /= 2.
        beta = last_alpha * (1 - last_alpha) / (last_alpha ** 2 + alpha)
        Q = R + beta * (R - R_prev)

        alphas.append(alpha)
        betas.append(beta)

        abs_errs.append(np.linalg.norm((Z - (J - R).apply(T)).to_numpy(), 'fro'))
        rel_errs.append(abs_errs[-1] / np.linalg.norm(Z.to_numpy(), 'fro'))
        update_norm = np.linalg.norm(to_matrix(J_prev - J), 'fro') / np.linalg.norm(to_matrix(J), 'fro') \
                    + np.linalg.norm(to_matrix(R_prev - R), 'fro') / np.linalg.norm(to_matrix(J), 'fro')
        update_norms.append(update_norm)

    data['update_norms'] = np.array(update_norms)
    data['abs_errs'] = np.array(abs_errs)
    data['rel_errs'] = np.array(rel_errs)
    data['iterations'] = iteration
    data['skew_procrustes_data'] = procrustes_data

    inf_J = J.blocks[0, 0]
    inf_G = J.blocks[0, 1]
    inf_N = J.blocks[1, 1]
    inf_R = R.blocks[0, 0]
    inf_P = R.blocks[0, 1]
    inf_S = R.blocks[1, 1]
    inf_model = PHLTIModel(
        J=inf_J, R=inf_R, G=inf_G, P=inf_P, N=inf_N, S=inf_S, E=H
    )

    return inf_model, data


def _weighted_phdmd(X, Y, rtol=1e-12):
    r"""Solve the weighted pH DMD problem.

    This method solves the optimization problem::

        min ||T^T Z - T^T (J - R) T||_F

    such that :math:`J` is a skew-symmetric matrix and :math:`R` is symmetric and positive
    semidefinite. The data matrices :math:`T` and :math:`Z` are constructed as follows::

        T = (X, U)^T, Z = (H \dot{X}, -Y)^T

    from `X`, `Y`, `U`, and either derivative `Xdot` or an approximation of the derivative data
    obtained from `X` itself.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system data.
    Y
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system output data.
    rtol
        Truncate the singular values when the ratio with respect to the largest singular value
        is below this threshold.

    Returns
    -------
    J
        The initial :class:`~pymor.operators.block.BlockOperator` for `J`.
    R
        The initial :class:`~pymor.operators.block.BlockOperator` for `R`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute solution error.
            :rel:   Value of relative solution error.
    """
    assert isinstance(X, VectorArray) and isinstance(Y, VectorArray)
    assert X.space == Y.space

    logger = getLogger('pymor.algorithms.phdmd.weighted_phdmd')

    total_data_dim = X.dim
    space_dim = X.space.subspaces[0].dim
    space_id = X.space.subspaces[0].id

    U, s_vals, V = svd(X.to_numpy().T)

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_S = diags(s_vals[:rank])
    trunc_S_inv = diags(1. / s_vals[:rank])

    if rank < total_data_dim:
        logger.warn(f'Deficient rank ({rank} < {total_data_dim})!')

    Z_1 = U.T @ Y.to_numpy().T @ V.T

    helper = trunc_S @ Z_1[:rank, :rank]
    J_11 = .5 * (helper - helper.T)
    R_11 = _project_spsd(-helper, dim=space_dim)
    J = U[:, :rank] @ trunc_S_inv @ J_11 @ trunc_S_inv @ U[:, :rank].T
    R = U[:, :rank] @ trunc_S_inv @ to_matrix(R_11) @ trunc_S_inv @ U[:, :rank].T

    if rank < total_data_dim:
        J_21, _, _, _ = lstsq(trunc_S.todense(), Z_1[rank:, :rank].T, cond=None)
        top_filler = np.zeros((total_data_dim - rank, total_data_dim - rank))
        bottom_filler = np.zeros((rank, rank))
        compensation = np.block([
            [top_filler, J_21.T],
            [-J_21, bottom_filler]
        ])

        J = J + U @ compensation @ U.T

    J = BlockOperator([
        [
            NumpyMatrixOperator(J[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
            NumpyMatrixOperator(J[:space_dim, space_dim:], range_id=space_id)
        ],
        [
            NumpyMatrixOperator(J[space_dim:, :space_dim], source_id=space_id),
            NumpyMatrixOperator(J[space_dim:, space_dim:])
        ]
    ])
    R = BlockOperator([
        [
            NumpyMatrixOperator(R[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
            NumpyMatrixOperator(R[:space_dim, space_dim:], range_id=space_id)
        ],
        [
            NumpyMatrixOperator(R[space_dim:, :space_dim], source_id=space_id),
            NumpyMatrixOperator(R[space_dim:, space_dim:])
        ]
    ])

    abs_err = np.linalg.norm(X.inner(Y) - (J - R).apply2(X, X), 'fro')
    rel_err = abs_err / np.linalg.norm(X.inner(Y), 'fro')
    data = {'abs': abs_err, 'rel': rel_err}

    return J, R, data


def _project_spsd(matrix, dim, id=None):
    """Project the matrix onto the set of symmetric and positive semidefinite matrices.

    Not intended to be used directly.

    Parameters
    ----------
    matrix
        The `NumPy array` containing the matrix to project.

    Returns
    -------
    A
        The :class:`~pymor.operators.block.BlockOperator` containing the projected matrix.
    """
    assert isinstance(matrix, np.ndarray)
    assert len(matrix.shape) == 2

    matrix = .5 * (matrix + matrix.T)
    eig_vals, eig_vecs = eigh(matrix)
    projected = eig_vecs @ diags(eig_vals.clip(min = 0)) @ eig_vecs.T
    A = BlockOperator([
        [
            NumpyMatrixOperator(projected[:dim, :dim], source_id=id, range_id=id),
            NumpyMatrixOperator(projected[:dim, dim:], range_id=id)
        ],
        [
            NumpyMatrixOperator(projected[dim:, :dim], source_id=id),
            NumpyMatrixOperator(projected[dim:, dim:])
        ]
    ])

    return A


def _skew_symmetric_procrustes(X, Y, rtol=1e-12):
    """Solve the skew-symmetric Procrustes problem.

    Computes a solution A of the minimization problem ::

        min ||AX - Y||_F

    used in the ph DMD algorithm, such that :math:`A` is skew-symmetric .

    Not intended to be used directly.

    Parameters
    ----------
    X
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system data.
    Y
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system output data.
    rtol
        Truncate the singular values and matrix entries of :math:`A` when the ratio with respect
        to the largest value is below this threshold.

    Returns
    -------
    A
        The :class:`~pymor.operators.block.BlockOperator` containing the matrix mapping `X` to `Y`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute fitting error.
            :rel:   Value of relative fitting error.
    """
    assert isinstance(X, VectorArray) and isinstance(Y, VectorArray)
    assert X.space == Y.space

    total_data_dim = X.dim
    space_dim = X.space.subspaces[0].dim
    space_id = X.space.subspaces[0].id

    U, s_vals, V = np.linalg.svd(X.to_numpy().T)
    V = V.conj().T

    rank = np.argmax(s_vals / s_vals[0] < rtol)
    rank = rank if rank > 0 else len(s_vals)

    trunc_s_vals = s_vals[:rank]
    trunc_S = diags(trunc_s_vals)

    Y_trans = U.T @ Y.to_numpy().T @ V
    Z_1 = Y_trans[:rank, :rank]
    Z_3 = Y_trans[rank:, :rank].T

    [ii, jj] = np.mgrid[:rank, :rank]
    phi = 1. / (np.square(trunc_s_vals[ii]) + np.square(trunc_s_vals[jj]))

    A_1 = phi * (Z_1 @ trunc_S - trunc_S @ Z_1.T)
    A_2 = -spsolve(trunc_S.tocsc(), Z_3)
    # if dimensions are unfortunately chosen, spsolve results in the following shapes:
    # Z_3.shape = (x, 1) -> A_2.shape = (x,)
    # this then breaks the hstack(...) afterwards
    if A_2.ndim == 1:
        A_2 = A_2[:, np.newaxis]
    A_4 = np.zeros((total_data_dim - rank, total_data_dim - rank))
    A = np.block([
        [A_1, A_2],
        [-A_2.T, A_4]
    ])
    A = U @ A @ U.T

    A_abs = np.abs(A)
    indices = np.where(A_abs / np.amax(A_abs) < rtol)
    A[indices] = 0.

    A = BlockOperator([
        [
            NumpyMatrixOperator(A[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
            NumpyMatrixOperator(A[:space_dim, space_dim:], range_id=space_id)
        ],
        [
            NumpyMatrixOperator(A[space_dim:, :space_dim], source_id=space_id),
            NumpyMatrixOperator(A[space_dim:, space_dim:])
        ]
    ])

    abs_err = np.linalg.norm((A.apply(X) - Y).to_numpy(), 'fro')
    rel_err = abs_err / np.linalg.norm(Y.to_numpy(), 'fro')
    data = {'abs': abs_err, 'rel': rel_err}

    return A, data


def _initial_psd_symmetric_procrustes(X, Y, reg=1e-6):
    """Solve the psd symmetric Procrustes problem.

    Computes a solution A of the minimization problem ::

        min ||AX - Y||_F

    used as an initial guess in the pH DMD algorithm such that :math:`A` is
    symmetric and positive semidefinite.

    Not intended to be used directly.

    Parameters
    ----------
    X
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system data.
    Y
        The :class:`~pymor.vectorarrays.block.BlockVectorArray` of the system output data.
    reg
        Regularization parameter applied to every element on the main diagonal
        to avoid singular matrices.

    Returns
    -------
    A
        The :class:`~pymor.operators.block.BlockOperator` containing the matrix mapping `X` to `Y`.
    data
        Dict containing the following fields:

            :abs:   Value of absolute fitting error.
            :rel:   Value of relative fitting error.
    """
    assert isinstance(X, VectorArray) and isinstance(Y, VectorArray)
    assert X.space == Y.space

    data_dim = X.dim
    space_dim = X.space.subspaces[0].dim
    space_id = X.space.subspaces[0].id

    A = np.zeros((data_dim, data_dim))
    for i in range(data_dim):
        X_row = X.to_numpy().T[i]
        A[i, i] = max(0, X_row @ Y.to_numpy()[:, i]) / np.linalg.norm(X_row) ** 2 + reg

    A = BlockOperator([
        [
            NumpyMatrixOperator(A[:space_dim, :space_dim], source_id=space_id, range_id=space_id),
            NumpyMatrixOperator(A[:space_dim, space_dim:], range_id=space_id)
        ],
        [
            NumpyMatrixOperator(A[space_dim:, :space_dim], source_id=space_id),
            NumpyMatrixOperator(A[space_dim:, space_dim:])
        ]
    ])

    abs_err = np.linalg.norm((Y - A.apply(X)).to_numpy(), 'fro')
    rel_err = abs_err / np.linalg.norm(Y.to_numpy(), 'fro')

    data = {}
    data = {'abs': abs_err, 'rel': rel_err}

    return A, data
